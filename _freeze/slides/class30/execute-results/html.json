{
  "hash": "135a955ba1a4f41805a9eb3249a6b5dd",
  "result": {
    "markdown": "---\ntitle: \"Physician Learning\"\nauthor: \"Ian McCarthy | Emory University\"\nformat: \n  revealjs:\n    theme: [moon]\n    preview-links: auto\n#    chalkboard:\n#      boardmarker-width: 5\n    slide-number: true\n    width: 1600\n    height: 900    \n    embed-resources: true\nfrom: markdown+emoji\nexecute: \n  echo: true\n---\n\n\n\n\n\n# Some Background\n\n---\n\n## A Primer on Learning Models (@ching2013)\n\n- Often modeled as consumer learning, but the basic setup is the same\n- Consumers have incomplete information about product attributes and learn about them over time (e.g., through experience)\n- Today, we'll work through the basics of a consumer learning model\n\n---\n\n## Discrete Choice vs Learning\n\n- \"work within the traditional random utility framework maintains the strong assumption that consumers know the attributes of their choice options perfectly\"\n- More realistically, \"they make choices based on perceived attributes. Over time, consumers receive information signals that enable them to learn more about products. It is this inherent temporal aspect of learning models that distinguishes them from static choice under uncertainty models.\"\n\n---\n\n## Key aspects of learning models\n\n1. Forward-looking versus myopic\n2. Linear versus risk-averse\n3. Sources of information\n4. Updating rules (Bayesian, etc.)\n\n---\n\n## Timeline of literature\n\n- Pre 1996: Computational limitations necessitated very simple structures that did not capture much of the complexity of learning\n- @erdem1996: First paper to use Bayesian updating in a learning model, employing new methods from @keane1994 to greatly simplify estimation of dynamic discrete choice models\n- Post 1996 (really post 2000): Extension of learning models with more complex structures (at least in some dimensions)\n\n\n# Erdem and Keane (1996)\n\n---\n\n## Basic Structure\n\n- Consumers have incomplete information about product quality\n- Prior: $q_{j} \\sim N(q_{j1}, \\sigma_{j1}^{2})$ for $j=1,..., J$\n- Consumers observe quality through experience, but it is a noisy signal of true quality $\\tilde{q}_{jt} = q_{j} + \\epsilon_{jt}$ where $\\epsilon_{jt} \\sim N(0, \\sigma_{\\epsilon}^{2})$\n- Note: the the prior and the signal are assumed to follow a normal distribution, thus we have conjugate priors (the prior combines with the signal to form a closed form distribution for the posterior, in this case another normal distribution)\n\n$$\\begin{align}\nq_{j2} &= \\frac{\\sigma_{j1}^{2}}{\\sigma_{j1}^{2} + \\sigma_{\\epsilon}^{2}}\\tilde{q}_{j1} + \\frac{\\sigma_{\\epsilon}^{2}}{\\sigma_{j1}^{2} + \\sigma_{\\epsilon}^{2}}q_{j1} \\\\\\\n\\sigma_{j2}^{2} &= \\frac{1}{\\frac{1}{\\sigma_{j1}^{2}} + \\frac{1}{\\sigma_{\\epsilon}^{2}}}\\end{align}$$\n\n---\n\n## Multiple Periods\n\nGeneralizing to $N_{j}(t)$ periods, we have:\n\n$$\\begin{align}\nq_{jt} &= \\frac{\\sigma_{j1}^{2}}{N_{j}(t) \\sigma_{j1}^{2} + \\sigma_{\\epsilon}^{2}}\\sum_{s=1}^{t-1}\\tilde{q}_{js}d_{js} + \\frac{\\sigma_{\\epsilon}^{2}}{N_{j}(t) \\sigma_{j1}^{2} + \\sigma_{\\epsilon}^{2}}q_{j1} \\\\\\\n\\sigma_{jt}^{2} &= \\frac{1}{\\frac{1}{\\sigma_{j1}^{2}} + N_{j}(t) \\frac{1}{\\sigma_{\\epsilon}^{2}}},\\end{align}$$\n\nwhere $N_{j}(t)$ denotes the number of signals received up to time $t$, and $d_{js}$ is a dummy variable that equals 1 if a signal is received for product $j$ at time $s$ and 0 otherwise.\n\n- Posterior mean, $q_{jt}$, is a weighted average of the prior and all quality signals received up to time $t$\n- Posterior variance, $\\sigma_{jt}^{2}$, decreases with the number of signals received\n- In the limit, as $t \\rightarrow \\infty$, the posterior mean converges to the true quality of the product\n\n---\n\n## Utility\n\n- Today's purchase affects tomorrow's information set, which affects future utility, etc.\n- Requires dynamic programming to solve for the optimal decisions (in general), with\n\n$$V(j, t | I_{t}) = U(j,t | I_{t}) + \\beta EV(I_{t+1} | I_{t}, j),$$ where\n\n- $U(.)$ is utility of product $j$ at time $t$ given information set $I_{t}$\n- $EV(.)$ is the expected present value of future payoffs conditional on $I_{t}$ and $j$\n\n---\n\n## Forward-looking learning\n\n- May be optimal to choose a brand with lower perceived quality today if it provides more information\n- Consider a special case where of selecting between a new product $n$ or an old product $o$\n- $V(n,t | I_{t}) = q_{nt} - p_{nt} + e_{nt} + \\beta EV(I_{t+1} | I_{t}, n)$, where $I_{t+1} = \\{q_{n,t+1}, \\sigma^{2}_{n,t+1}\\}$\n- $V(o,t | I_{t}) = q_{ot} - p_{ot} + e_{ot} + \\beta EV(I_{t+1} | I_{t}, o)$, where $I_{t+1} = I_{t}$\n- The consumer chooses $n$ if $V_{nt}^{*} \\equiv V(n,t | I_{t}) > V(o,t | I_{t}) > 0$\n\n$$\\begin{align}\nV_{nt}^{*}  &= (q_{nt} - p_{nt}) - (q_{ot} - p_{ot}) + (e_{nt}-e_{ot}) + \\beta (EV(I_{t+1} | I_{t}, n) - EV(I_{t_1}|I_{t},o) \\\\\\\n &=(q_{nt} - p_{nt}) - (q_{ot} - p_{ot}) + (e_{nt}-e_{ot}) + G_{t}.\\end{align}$$\n\n- Can be shown that $G_{t}>0$ so that more information is always better\n\n---\n\n## Estimation\n\n- Complicated due to expected value of future payoffs, $$EV(I_{t+1} | I_{t}, j) = E_{t} \\max \\{V(1, t+1 | I_{t+1}), V(2, t+1 | I_{t+1}), ..., V(J, t+1 | I_{t+1})\\}$$\n- Decision maker can form expected maximum, but this just pushes the problem one period ahead\n- How do we fully solve the dynamic optimization problem?\n\n---\n\n## Estimation\n\n- Key insight is that there exists a terminal period, $T$\n- $V(j,T | I_{T}) = E[U(j,T) | I_{T}]$ for all $j$...so\n\n$$EV(I_{T} | I_{T-1}, j) = E_{T-1} \\max \\{ E[U(1, T) | I_{T}], ..., E[U(J, T) | I_{T}] \\},$$\n\n---\n\n## Estimation\n\n$$EV(I_{T} | I_{T-1}, j) = E_{T-1} \\max \\{E[U(1, T) | I_{T}], ..., E[U(J, T) | I_{T}] \\}$$\n\n- Can be solved for explicitly in some settings (e.g., only error is $e_{jt}$ with logit assumptions)\n- Can be solved for numerically in other settings (e.g., with more general error structures or multiple signals per period)\n- With $EV(I_{T} | I_{T-1}, j)$, we can solve for $V(j,T-1 | I_{T-1}) = E[U(j,T-1) | I_{T-1}] + \\beta EV(I_{T} | I_{T-1}, j)$\n\n\n---\n\n## Barriers to estimation\n\n- Solving by backward induction is intuitively appealing but computationally infeasible\n- Neet to calculate $EV(I_{T} | I_{T-1}, j)$ for all possible $(I_{T-1},j)$\n- In this simple setup, we have $2\\times J$ variables at any given time (quality and variance for each product)\n- And those variables are continuous, so the full state space has infinitely many points\n- Need to discretize the state space (e.g., with $G$ grid points)\n- Yields $G^{2 \\times J}$ grid points...still too many for practical estimation\n\n---\n\n## Erdem and Keane (1996) and Keane and Wolpin (1994)\n\n- Key insight: Randomly selected subset of state points\n- Expected value functions approximate out-of-sample (e.g., based on a regression from the subset of sampled state points)\n\n---\n\n## Final estimation\n\n- Dynamic programming solution/approximation must be performed for each iteration of the likelihood estimation\n- But...identification is a problem in these models\n- At a minimum, need a normalization since only utility differences matter for choice\n- For things that only enter into $EV(.)$ terms, identification requires variation in information sets across decision-makers\n\n---\n\n## References",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}